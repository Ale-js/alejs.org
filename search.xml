<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>安装</title>
      <link href="/2018/12/01/Install/"/>
      <url>/2018/12/01/Install/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>Ale 不支持 IE8 及以下版本，因为 Ale 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p><h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><p>最新稳定版本：<strong>1.0-Beta.1</strong></p><p>每个版本的更新日志见 <a href="https://github.com/Ale-js/ale/releases" target="_blank" rel="noopener">GitHub</a>。</p><h3 id="直接用-lt-script-gt-引入"><a href="#直接用-lt-script-gt-引入" class="headerlink" title="直接用 &lt;script&gt; 引入"></a>直接用 &lt;script&gt; 引入</h3><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，<code>Ale</code> 会被注册为一个全局变量。</p><p></p><p class="info-box">不要在生产版本下使用未经压缩的 <code>ale.js</code> 文件，否则这会降低你的文件加载速度！</p><p></p><p><a href="https://github.com/Ale-js/ale/tree/master/dist" target="_blank" rel="noopener"><button class="post-btn" style="margin-bottom: 15px">开发版本</button></a><br><a href="https://github.com/Ale-js/ale/releases" target="_blank" rel="noopener"><button class="post-btn">生产版本</button></a></p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>我们推荐链接到一个你可以手动更新的指定版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/alejs@1.0/ale.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>请确认了解不同构建版本并在你发布的站点中使用生产环境版本，把 <code>ale.js</code> 换成 <code>ale.min.js</code>。</p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>在用 Ale 构建大型应用时推荐使用 NPM 安装，因为 NPM 能很好地和诸如 webpack 或 browserify 这种的模块打包器配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line">$ npm i alejs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Data</title>
      <link href="/2018/12/01/ComponentData/"/>
      <url>/2018/12/01/ComponentData/</url>
      
        <content type="html"><![CDATA[<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>In the <a href="/2018/12/01/ComponentFoundation/">Component Basics</a> article, I believe you have already learned some basic ways to add data. If you haven’t studied this tutorial yet, please come back after learning!</p><p>In the component-based tutorial, you only learned how to add <code>data</code>. So why add dynamic <code>data</code>?</p><p><br></p><p>It’s actually very simple, because the template is static and the data is dynamic. If we change somewhere, it’s actually much simpler than changing the template!</p><p>For example, we first define a component named <code>com1</code> and then render it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;Hello &quot; + this.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>The rendering results are as follows:</p><p id="app" class="demo"></p><p>So since we know that we can modify the data dynamically, how can we modify it?</p><p><br></p><p>Quite simply, we just need to store the result returned by the <code>Ale.render</code> function (which is actually the Ale component object) into a variable:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var app = Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Then use this variable to manipulate <code>data</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.data.name = &quot;Ale.js&quot;; /* Reassign */</span><br></pre></td></tr></table></figure><p>Now let’s type <code>app.data.name = &quot;Ale.js&quot;</code> in the console, and you’ll see the following instance dynamic update:</p><p id="app2" class="demo"></p><p>At the same time, our data will be automatically bound to all elements within the component, accessible using <code>this.data</code>, for example, we will be a component that records clicks:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Defining components */</span><br><span class="line">Ale(&quot;counter&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        /* Let this.data.count increase itself */</span><br><span class="line">        return &quot;&lt;button onclick=&apos;this.data.count++&apos;&gt;You clicked me &quot; + this.count + &quot; times.&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* Rendering component */</span><br><span class="line">Ale.render(&quot;counter&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>In fact, the data can be applied not only to the template, but also to the properties of any supported function. Of course, the properties of these bound data will be updated whenever you update the data.</p><p>What are the specific properties that can be applied to the data, please continue to view the tutorial!</p><h3 id="advanced"><a href="#advanced" class="headerlink" title="advanced"></a>advanced</h3><p>If you know Vue, you will find that using Vue to set the data requires adding a function and then using return to return the required data:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        /* Add data here */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue does this because each time the JavaScript engine copies an object, it is copied along with the object’s memory address, which causes another object to be updated when an object is updated. At this time, if we use a function to return an object each time, it is equivalent to creating a new object with a different memory address each time, there will be no such problem.</p><p><br></p><p>However, doing so will result in an increase in the amount of code you need to write, while Ale uses a deep copy to scan from the root of the object and create a brand new object layer by layer. Doing so will cause a certain performance penalty (ignoring small amounts of data), but it also reduces the amount of code you need to write.</p><p><br></p><p>If you need multiple components to share a set of data, try having one component render multiple elements at the same time in one rendering, or use <a href="/2018/12/01/ComponentImport">composite component</a>.</p><script src="../../../../js/ale.min.js"></script><script>Ale("com1", {    template: function(){        return "Hello " + this.name;    },    data: {        name: "World"    }})Ale.render("com1", {    el: "#app"})var app = Ale.render("com1", {    el: "#app2"})Ale("counter", {    template: function(){        return "<button onclick='this.data.count++'>You clicked me " + this.count + " times.";    },    data: {        count: 0    }})Ale.render("counter", {    el: "#app3"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>生命周期</title>
      <link href="/2018/12/01/ComponentLife/"/>
      <url>/2018/12/01/ComponentLife/</url>
      
        <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在 Ale 中，一个组件共有六种生命状态，分别对应着它们的同名生命周期函数：</p><ul><li>using（组件被使用时）</li><li>mounting（组件被插入真实 DOM 时）</li><li>unmounting（组件移出真实 DOM 时）</li><li>rendering（组件被渲染时）</li><li>updating（组件更新时）</li><li>destroy（组件被销毁时）</li></ul><p>你可以在定义组件时添加一个名为 <code>life</code> 的属性，并在 <code>life</code> 属性里添加函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    template: &quot;test&quot;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        /* 这里添加life属性，需要为object */</span><br><span class="line">        /* 添加using函数，当组件被使用时触发 */</span><br><span class="line">        using: function()&#123;</span><br><span class="line">            alert(&quot;using!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"><button onclick="Ale.render('test',{el: '#app'})">点我渲染 test 组件</button></p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>除了 using 函数，其他的函数都将自动绑定 Ale 组件对象。如果你需要更改 data，请使用 <code>this.data</code> 这种形式更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    template: &quot;test&quot;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        /* 这里添加life属性，需要为object */</span><br><span class="line">        /* 添加rendering函数，当组件被渲染时触发 */</span><br><span class="line">        rendering: function()&#123;</span><br><span class="line">            console.log(this.data); /* 打印data */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p>让我们来制作一个定时器，输出当前时间，每秒更新一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;timer&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;Now Time: &quot; + this.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: new Date().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: function()&#123;</span><br><span class="line">            /* 这里需要使用箭头函数，因为不会绑定 this */</span><br><span class="line">            this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">                this.data.time = new Date().toLocaleTimeString();</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: function()&#123;</span><br><span class="line">            clearInterval(this.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;timer&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><p>上方定时器不会应用 Ale 内置的 <code>diff</code> 算法，因为你需要将不需要更新的元素用 DOM 标签包裹起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template: function()&#123;</span><br><span class="line">    return &quot;&lt;span&gt;Now Time: &lt;/span&gt;&quot; + this.time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>现在你可以打开控制台，对比一下这两个实例 DOM 的刷新，你会发现这个实例的 <code>Now Time:</code> 并没有更新。</p><script src="../../../../js/ale.min.js"></script><script>Ale("test", {    template: "test",    life: {        using: function(){            alert("using!");        }    }})Ale("timer", {    template: function(){        return "Now Time: " + this.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer", {    el: "#app2"})Ale("timer2", {    template: function(){        return "<span>Now Time: </span>" + this.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer2", {    el: "#app3"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>组件基础</title>
      <link href="/2018/12/01/ComponentFoundation/"/>
      <url>/2018/12/01/ComponentFoundation/</url>
      
        <content type="html"><![CDATA[<h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在介绍章节中，你已经学习了一些基础的定义和渲染组件的函数。这些基础将不会在本章中出现，如果你还没有学习过部分内容，请访问 <a href="/2018/12/01/Introduction/">介绍</a> 页面。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在介绍页面，我们已经了解了关于 <strong>template</strong> 属性的一些知识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名为 com1 的组件</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template: &quot;HelloWorld&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实，<strong>template</strong> 属性还支持接收一个函数，但是具体的模板需要使用<code>return</code>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名为 com1 的组件</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;HelloWorld&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//当然，你也可以使用 ES6 语法来定义模板</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template()&#123;</span><br><span class="line">        return &quot;HelloWorld&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后我们需要去渲染这个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot; /* 目标元素选择器 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>那么，将 <strong>template</strong> 属性设置为函数有什么好处呢？其实，它可以自动绑定一个叫 <code>data</code> 的属性。</p><p>例如我们在 <code>data</code> 属性里定义一个名为<code>name</code>的值，然后渲染它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;Hello &quot; + this.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* 切记一定不可使用 ES6 的箭头函数，因为箭头函数不会绑定 this</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    template: () =&gt; &#123;</span><br><span class="line">        return &quot;Hello &quot; + this.name; //错误！</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;World&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><p>你也可以在组件被渲染时动态设置 <code>data</code>。其中，重名的属性将会被重新赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;Ale.js&quot; /* 会被重新赋值为 Ale.js */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>当然，同一个组件也可以被渲染多次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app2&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app3&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;Ale.js&quot; /* 也可以拥有不同的属性 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><script src="../../../../js/ale.min.js"></script><script>Ale("com1", {    template: function(){        return "HelloWorld";    }});Ale.render("com1", {    el: "#app"})Ale("com2", {    template: function(){        return "Hello "+this.name;    },    data: {        name: "World"    }});Ale.render("com2", {    el: "#app2"})Ale.render("com2", {    el: "#app3",    data: {        name: "Ale.js"    }})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>复合组件</title>
      <link href="/2018/12/01/ComponentImport/"/>
      <url>/2018/12/01/ComponentImport/</url>
      
        <content type="html"><![CDATA[<h1 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>Ale 允许你将任意的组件使用 <code>imports</code> 属性绑定到一起，绑定后的新组件将会成为一个 <code>复合组件</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个名为test-1的组件 */</span><br><span class="line">Ale(&quot;test-1&quot;, &#123;</span><br><span class="line">    template: &quot;Hello&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 定义一个名为test的组件，然后引入test-1 */</span><br><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-1&quot;], /* 这里需要为一个数组 */</span><br><span class="line">    template: &quot;World&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完成之后，<code>test</code>组件就变成了一个复合组件。</p><p>那么现在如果我们渲染<code>test</code>组件，那么它只会输出<code>World</code>，而不是我们需要的<code>HelloWorld</code>。这时我们可以在<code>test</code>组件的模板属性里使用自定义标签添加<code>test-1</code>组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-1&quot;],</span><br><span class="line">    template: &quot;&lt;test-1/&gt;World&quot; /* 注意这里，我们使用&lt;test-1/&gt;这种格式渲染了test-1组件 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中，我们使用<code>&lt;test-1/&gt;</code>这种格式渲染了test-1组件，那么需要注意的是，自定义标签只能为这种格式，<strong>一个空格都不能多加！</strong></p><p>现在让我们来渲染一下这个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(&quot;test&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>已经正常工作了，对吧？其实你不只可以引入单组件，还可以引入复合组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个名为test-1的组件 */</span><br><span class="line">Ale(&quot;test-1&quot;, &#123;</span><br><span class="line">    template: &quot;Hello&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 定义一个名为test-2的组件 */</span><br><span class="line">Ale(&quot;test-2&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-1&quot;],</span><br><span class="line">    template: &quot;&lt;test-1/&gt; &quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 定义一个名为test的组件，然后引入test-2 */</span><br><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-2&quot;],</span><br><span class="line">    template: &quot;&lt;test-2/&gt;World&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>复合组件相比普通（单）组件：</p><ul><li>整个复合组件共用一个<code>data</code>。也就是说，复合组件之间没有层级关系，任何组件都可以操作另外的所有组件里的数据。<strong>（另外，按imports导入的先后顺序，同名的数据将会覆盖之前的同名数据）</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个名为test-1的组件 */</span><br><span class="line">Ale(&quot;test-1&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return this.h; /* 这里访问了test组件的数据 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 定义一个名为test-2的组件 */</span><br><span class="line">Ale(&quot;test-2&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-1&quot;],</span><br><span class="line">    template: &quot;&lt;test-1/&gt; &quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 定义一个名为test的组件，然后引入test-2 */</span><br><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    imports: [&quot;test-2&quot;],</span><br><span class="line">    template: &quot;&lt;test-2/&gt;World&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        h: &quot;Hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><script src="../../../../js/ale.min.js"></script><script>Ale("test-1", {    template: "Hello"})Ale("test", {    imports: ["test-1"],    template: "<test-1/>World"})Ale.render("test", {    el: "#app"})Ale("test-2", {    imports: ["test-1"],    template: "<test-1/> "})Ale("test-3", {    imports: ["test-2"],    template: "<test-2/>World"})Ale.render("test-3", {    el: "#app2"})Ale("test-4", {    template: function(){        return this.h;    }})Ale("test-5", {    imports: ["test-4"],    template: "<test-4/> "})Ale("test-6", {    imports: ["test-5"],    template: "<test-5/>World",    data: {        h: "Hello"    }})Ale.render("test-6", {    el: "#app3"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Method</title>
      <link href="/2018/12/01/ComponentMethod/"/>
      <url>/2018/12/01/ComponentMethod/</url>
      
        <content type="html"><![CDATA[<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>让我们接着组件 <a href="/2018/12/01/ComponentLife/">生命周期</a> 的教程来讲解，还是定时器的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;timer&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;&lt;span&gt;Now Time: &lt;/span&gt;&quot; + this.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: new Date().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: function()&#123;</span><br><span class="line">            /* 这里需要使用箭头函数，因为不会绑定 this */</span><br><span class="line">            this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">                this.data.time = new Date().toLocaleTimeString();</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: function()&#123;</span><br><span class="line">            clearInterval(this.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;timer&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p class="demo" id="app">&lt;/p</p><p>不知道你有没有注意到，我们的定时器直接添加在 <code>this</code> 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 注意这里，直接绑定到 Ale组件对象上(this) */</span><br><span class="line">this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">    this.data.time = new Date().toLocaleTimeString();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>可是，如果我们不小心，添加的函数与 <code>Ale组件对象</code> 里的内置函数重名了，那么将会有一些未知 BUG 出现。</p><p>这时，我们推荐你将函数添加到 <code>Ale组件对象</code> 里的内置属性 <code>methods</code> 上！</p><p>让我们修改一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;timer&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return &quot;&lt;span&gt;Now Time: &lt;/span&gt;&quot; + this.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: new Date().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: function()&#123;</span><br><span class="line">            /* 注意这里，绑定methods上 */</span><br><span class="line">            this.methods.timer = setInterval(() =&gt; &#123;</span><br><span class="line">                this.data.time = new Date().toLocaleTimeString();</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: function()&#123;</span><br><span class="line">            clearInterval(this.methods.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实例是可以正常执行的。</p><p>同时，你也可以在组件定义时设置 <code>methods</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    template: &quot;test&quot;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        /* 定义一个名为 testFn 的函数 */</span><br><span class="line">        testFn: function()&#123;</span><br><span class="line">            alert(&quot;test!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: function()&#123;</span><br><span class="line">            /* 动态调用它 */</span><br><span class="line">            this.methods.testFn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>同 <code>data</code> 属性一样，<code>methods</code> 属性也会自动绑定到组件的全部元素及子元素上，通过 <code>this.methods</code> 即可访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: &quot;&lt;span onclick=&apos;this.methods.testFn()&apos;&gt;Click me!&lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure><div class="demo" id="app2"></div><script src="../../../../js/ale.min.js"></script><script>Ale("timer", {    template: function(){        return "<span>Now Time: </span>" + this.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer", {    el: "#app"})Ale("test", {    template: "<span onclick='this.methods.testFn()'>Click me!</span>",    methods: {        testFn: function(){            alert("test!")        }    }})Ale.render("test", {    el: "#app2"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>组件对象</title>
      <link href="/2018/12/01/ComponentObj/"/>
      <url>/2018/12/01/ComponentObj/</url>
      
        <content type="html"><![CDATA[<h1 id="组件对象"><a href="#组件对象" class="headerlink" title="组件对象"></a>组件对象</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>当你每次 <code>render</code> 一个组件时，Ale 都会返回一个 <code>Ale组件对象</code>，你可以定义一个变量来接收它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个变量接收 Ale组件对象 */</span><br><span class="line">var app = Ale.render(&quot;test&quot;, &#123;</span><br><span class="line">    /* ...... */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p id="app" class="demo"></p><p>让我们点击上方实例，你将会看到它在控制台中输出了它自己的<code>Ale组件对象</code>。</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>可是这造成了一个问题，如果我们的组件需要动态渲染，那我们怎么获取它的 <code>Ale组件对象</code> 呢？</p><p>很简单，只需要在支持函数的属性中使用 <code>this</code> 关键字即可获取 <strong>（由于<code>template</code>属性比较特殊，自动绑定的是<code>this.data</code>，所以在template属性中使用<code>this</code>代指的是<code>this.data</code>）</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个组件 */</span><br><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: function()&#123;</span><br><span class="line">            console.log(this) /* 这里this代指渲染完成之后的Ale组件对象 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上方实例中，可能你还不了解<code>life</code>属性的作用，不过我们就是给你演示一下如何使用，具体细节请继续往下查看教程！</p><p>目前全部支持函数的属性：</p><ul><li>template <strong>（由于<code>template</code>属性比较特殊，自动绑定的是<code>this.data</code>，所以在template属性中使用<code>this</code>代指的是<code>this.data</code>）</strong></li><li>life <strong>（life属性本身不支持函数，但是它内部的属性全部支持函数）</strong></li><li>debug <strong>（debug属性本身不支持函数，但是它内部的属性全部支持函数。<span style="color:red">不过注意，debug内部的函数<em>不会</em>绑定this</span>）</strong></li></ul><script src="../../../../js/ale.min.js"></script><script>Ale("aleComObj", {    template: "<button onclick='console.log(app)'>点我在控制台中输出我的：Ale组件对象</button>"})var app = Ale.render("aleComObj", {    el: "#app"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>调试模式</title>
      <link href="/2018/12/01/ComponentDebug/"/>
      <url>/2018/12/01/ComponentDebug/</url>
      
        <content type="html"><![CDATA[<h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>当你有一个庞大的前端系统时，如果没有办法监测数据的变化，那么调试就将变成噩梦。</p><p><code>debug</code> 参数的出现很好地解决了这个问题，你可以在组件<code>定义</code>或<code>渲染</code>时添加<code>debug</code>参数（渲染时的debug参数将会完全覆盖定义时设置的debug参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 在定义时添加 */</span><br><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    /* ...... */</span><br><span class="line">    debug: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* 或者在渲染时动态添加 */</span><br><span class="line">Ale.render(&quot;test&quot;, &#123;</span><br><span class="line">    /* ...... */</span><br><span class="line">    debug: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>debug</code>参数内置有两个函数：<code>setter</code>和<code>getter</code>，分别监测组件数据的设置和获取 <strong>（其中，setter和getter各需要一个参数，用来接收值）</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    /* ...... */</span><br><span class="line">    debug: &#123;</span><br><span class="line">        setter: function(val)&#123;</span><br><span class="line">            console.log(&quot;你设置了我为：&quot;+val);</span><br><span class="line">        &#125;,</span><br><span class="line">        getter: function(val)&#123;</span><br><span class="line">            console.log(&quot;你获取了我：&quot;+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>上方实例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    template: &quot;在控制台中获取或重设 app.data.data1 的值，然后查看控制台中的输出信息&quot;,</span><br><span class="line">    debug: &#123;</span><br><span class="line">        setter: function(val)&#123;</span><br><span class="line">            console.log(&quot;你设置了我为：&quot;+val);</span><br><span class="line">        &#125;,</span><br><span class="line">        getter: function(val)&#123;</span><br><span class="line">            console.log(&quot;你获取了我：&quot;+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        data1: &quot;Hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(&quot;test&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><script src="../../../../js/ale.min.js"></script><script>Ale("test", {    template: "在控制台中获取或重设 app.data.data1 的值，然后查看控制台中的输出信息",    debug: {        setter: function(val){            console.log("你设置了我为："+val);        },        getter: function(val){            console.log("你获取了我："+val);        }    },    data: {        data1: "Hello"    }})Ale.render("test", {    el: "#app"})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>介绍</title>
      <link href="/2018/12/01/Introduction/"/>
      <url>/2018/12/01/Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Ale-js是什么"><a href="#Ale-js是什么" class="headerlink" title="Ale.js是什么"></a>Ale.js是什么</h2><p>Ale (中文：啤酒) 是一套用于以组件的形式构建用户界面的渐进式框架。它信奉，万物皆组件。与其它大型框架不同的是，Ale 只需要你将关注点放在数据上，并不需要关心任何与视图有关的内容。当你更新数据时，视图中任何使用到它的地方都会得到更新。</p><p><br></p><p>我们将 <code>Vue</code> 和 <code>React</code> 的一些特性融合在 <code>Ale</code> 中，使之更加便捷、轻量。同时，<code>diff</code> 算法在 Ale 中也有应用（得益于 Ale 自研的 diff 算法，只有大约50行，极其轻量）。</p><p><br></p><p>同时，在 Ale 中，你也根本无需操心任何有关于 <strong>性能</strong> 方面的事情，因为 Ale 经过压缩后（非g-zip）只有大约7kb大小，执行速度也分别接近 Vue 和 React 的 <strong>3</strong> 倍！</p><p><br></p><p>如果你已经是有经验的前端开发者，想知道 Ale 与其它库 / 框架有哪些具体区别，请查看 <a href="/2018/12/01/Comparison">对比其它框架</a>。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p class="info-box">我们的官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意 —— 掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。<br></p><p>使用 Ale 最简单的例子就是制作一个 <code>HelloWorld</code> 页面，让我们先创建一个 <code>.html</code> 文件，然后通过如下方式引入 Ale：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开发环境版本 --&gt;</span><br><span class="line">&lt;script src=&quot;ale.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 生产环境版本，压缩了代码 --&gt;</span><br><span class="line">&lt;script src=&quot;ale.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>安装教程给出了更多安装 Ale 的方式，如果你想要了解更多关于 Ale 的安装方式，请访问 <a href="/2018/12/01/Install">安装教程</a></p><h3 id="第一个组件"><a href="#第一个组件" class="headerlink" title="第一个组件"></a>第一个组件</h3><p>已经引入好了 Ale 核心库文件？让我们开始制作我们的第一个组件吧！</p><p>在 Ale 中，所有的组件都是通过 <code>Ale</code> 函数创建的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale(); //当你引入了 Ale 核心库之后，Ale将会被注册为全局函数</span><br></pre></td></tr></table></figure><p><code>Ale</code> 函数接收<code>2</code>个参数，第一个参数用来设置这个组件的名称（字符串），第二个参数用来配置一些默认的参数（对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名为 com1 的组件</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    //配置</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，单纯这样还不能创建出一个最基本的组件，一个最基本的组件至少要在配置里添加一个叫 <code>template</code> 的参数，用来设置该组件的模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个名为 com1 的组件</span><br><span class="line">Ale(&quot;com1&quot;, &#123;</span><br><span class="line">    /* 配置模板为HelloWorld */</span><br><span class="line">    template: &quot;HelloWorld&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此，最基本的组件就定义完成了！</p><p>但是如果我们单纯只定义组件，而没有渲染它，那么这个组件将没有任何效果。这时我们可以使用 <code>Ale.render</code> 函数来渲染一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(); //渲染组件函数</span><br></pre></td></tr></table></figure><p><code>Ale.render</code> 函数也同样接收<code>2</code>个参数，和<code>Ale</code>函数一样，第一个参数用来设置这个组件的名称（字符串），第二个参数用来配置一些默认的参数（对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(&quot;com1&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot; /* 渲染一个组件时必须添加el属性，用来选中元素 */</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中<code>id</code>为<code>app</code>的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;app&apos;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>其中，每次渲染组件时都至少要添加一个配置参数，那就是 - <code>el</code>，用来设置需要选中的元素。这时，打开我们的<code>html</code>文件，你会发现组件渲染完成了：</p><p class="demo" id="app"></p><h3 id="准备好了吗"><a href="#准备好了吗" class="headerlink" title="准备好了吗"></a>准备好了吗</h3><p>恭喜，现在你已经创建完成了自己的第一个 <code>Ale</code> 组件！而我们的教程才刚刚开始 —— 本教程的其余部分将涵盖其它高级功能更详细的细节，所以请务必读完整个教程！</p><script src="../../../../js/ale.min.js"></script><script>    //定义一个名为 com1 的组件    Ale("com1", {        template: "HelloWorld"    })    Ale.render("com1", {        el: "#app"    })</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>深入响应式原理</title>
      <link href="/2018/12/01/deepInRespond/"/>
      <url>/2018/12/01/deepInRespond/</url>
      
        <content type="html"><![CDATA[<h1 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Ale 使用 ES5 全新的 <code>defineProperty</code> 属性给对象添加 setter 和 getter。同时 Object.defineProperty 是 ES5 中一个无法 shim 的特性，并不是语法糖，这也就是为什么 Ale 不支持 IE8 以及更低版本浏览器。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Ale <strong>不能检测到对象属性的添加或删除</strong>。由于 Ale 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Ale 转换它，这样才能让它是响应的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.a = 2; /* 响应式 */</span><br><span class="line"></span><br><span class="line">data.b = 2; /* 非响应式 */</span><br></pre></td></tr></table></figure><p>所以当你设置数据时，<strong>必需</strong> 设置需要具有响应式效果数据的值，哪怕它只是一个空值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &apos;&apos; /* 这里需要设置为空 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p>当你触发 setter（操作数据更新时），Ale 首先会更新这些数据，然后计算出更新后的全部属性结果，并循环更新。</p><p><br></p><p>其中，<code>template</code>属性比较特殊，当数据更新完成后，Ale 会调用 <code>diff</code> 算法的函数，并生成一个 <code>伪DOM结构体</code>，Ale的diff算法将会比较 <code>伪DOM结构</code> 和 <code>真实DOM结构</code> 的区别，并且只更新有差异的 DOM 元素。</p><p><br></p><p>另外，diff 对比只会在同级 DOM 中进行，一旦发生层级改变，Ale 将不会继续对比，而是直接更新整个层。这样可以有效地增加 diff 的对比性能，减少对比的时间。</p><p><br></p><p>还有一点，Ale 的 <code>diff</code> 算法只会对比元素的 <code>内容</code> \ <code>id</code> \ <code>class</code> \ <code>name</code> 属性是否相同，也就是说，当你动态更新例如 <code>onclick</code> 之类的属性，<code>diff</code> 算法是不会对比出差异的，而元素也就不会更新。这时你可以在元素更新时手动关闭 <code>diff</code> 算法，并在元素更新完成时开启即可！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>配置</title>
      <link href="/2018/12/01/config/"/>
      <url>/2018/12/01/config/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="config-函数"><a href="#config-函数" class="headerlink" title="config 函数"></a>config 函数</h3><p>Ale 函数内置了 <code>Ale.config</code> 函数，用来更改一些 Ale 配置信息。目前 config 函数支持的配置如下：</p><ul><li>html <strong>（默认false）</strong>【是否不自动转义html标签（可以预防xss攻击，不要轻易打开）】</li><li>diff <strong>（默认true）</strong>【是否在操作 DOM 时应用 diff 算法（推荐小应用关闭，中大型应用需要开启）】</li></ul><p>你可以通过如下方式更改某一种配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ale.config(&quot;html&quot;, true);</span><br><span class="line"></span><br><span class="line">/* 或 */</span><br><span class="line"></span><br><span class="line">Ale.config(&#123;</span><br><span class="line">    html: true,</span><br><span class="line">    diff: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>过滤器</title>
      <link href="/2018/12/01/filter/"/>
      <url>/2018/12/01/filter/</url>
      
        <content type="html"><![CDATA[<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p>Ale 函数内置了 <code>Ale.filter</code> 函数，在每次 DOM 更新时过滤敏感信息。</p><p>在 Ale 中，过滤器是一个队列。在你每次调用 <code>Ale.filter</code> 函数时，会自动往队列内插入过滤函数。你可以通过这种方式添加过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* filter函数接收一个参数，你可以传入一个函数。但是这个函数必须要有一个参数，然后将过滤的结果用return返回 */</span><br><span class="line">Ale.filter(function(msg)&#123;</span><br><span class="line"></span><br><span class="line">    /* 过滤全部数字1 */</span><br><span class="line">    msg = msg.replace(/1/g, &quot;&quot;)</span><br><span class="line">    return msg;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 或者你可以传入一个数组 */</span><br><span class="line">Ale.filter([function(msg)&#123;</span><br><span class="line"></span><br><span class="line">    /* 过滤全部数字1 */</span><br><span class="line">    msg = msg.replace(/1/g, &quot;&quot;)</span><br><span class="line">    return msg;</span><br><span class="line">&#125;, function(msg)&#123;</span><br><span class="line"></span><br><span class="line">    /* 过滤全部数字2 */</span><br><span class="line">    msg = msg.replace(/2/g, &quot;&quot;)</span><br><span class="line">    return msg;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p id="app" class="demo"></p><p>在上方实例中，我们添加了一个全局过滤器，它可以过滤掉所有的数字。现在你可以在控制台中输入 <code>app.data.str = &quot;新消息123&quot;</code>，看一下过滤器发挥的作用。</p><script src="../../../../js/ale.min.js"></script><script>Ale.filter(function(msg){    return msg.replace(/0/g, "").replace(/1/g, "").replace(/2/g, "").replace(/3/g, "").replace(/4/g, "").replace(/5/g, "").replace(/6/g, "").replace(/7/g, "").replace(/8/g, "").replace(/9/g, "");})Ale("com1", {    template: function(){        return this.str;    }});var app = Ale.render("com1", {    el: "#app",    data: {        str: "Hello World"    }})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>插件</title>
      <link href="/2018/12/01/plugin/"/>
      <url>/2018/12/01/plugin/</url>
      
        <content type="html"><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>我们需要使用 <code>Ale.use</code> 函数来加载一个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.use();</span><br></pre></td></tr></table></figure><p>其中，<code>Ale.use</code> 函数需要一个参数，来指定要加载的 Ale 插件对象。例如我们传入一个名为 <code>test</code> 的 Ale 插件对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.use(test);</span><br></pre></td></tr></table></figure><p><code>test</code> 其实就是一个变量。在下面的章节中，我们将会学习如何制作一个 Ale 插件对象。</p><h3 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h3><p>首先先让我们来定义一个<code>object</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 定义一个名为test的变量 */</span><br><span class="line">var test = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要想让 <code>test</code> 成为一个 Ale 插件对象，那么它至少要具备 <code>name</code> 和 <code>install</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var test = &#123;</span><br><span class="line">    name: &quot;test&quot;, /* 插件名称 */</span><br><span class="line">    install: function()&#123;</span><br><span class="line">        /* 安装函数，当用户 use 插件时会调用 */</span><br><span class="line">        alert(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在 <code>install</code> 属性里给 Ale 对象的 <code>prototype</code> 属性添加函数或属性…</p><p>反正随便啦，安装函数支持任意的 JavaScript 代码！</p><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p>我们已经定义了一个名为 <code>test</code> 的 Ale 插件对象，现在让我们在控制台中输入 <code>Ale.use(test)</code> 来安装它吧！（安装时会输出 Hello! ）</p><script src="../../../../js/ale.min.js"></script><script>var test = {    name: "test",    install: function(){        alert("Hello!");    }}</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>版本</title>
      <link href="/2018/12/01/version/"/>
      <url>/2018/12/01/version/</url>
      
        <content type="html"><![CDATA[<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><h3 id="version-属性"><a href="#version-属性" class="headerlink" title="version 属性"></a>version 属性</h3><p>你可以通过以下这种方式获取 Ale 当前的版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.version</span><br></pre></td></tr></table></figure><p>当前官网包含的 Ale 的版本为：</p><p class="demo" id="app"></p><script src="../../../../js/ale.min.js"></script><script>Ale("com1", {    template: function(){        return this.version;    }});Ale.render("com1", {    el: "#app",    data: {        version: Ale.version    }})</script>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Compare other frameworks</title>
      <link href="/2018/12/01/Comparison/"/>
      <url>/2018/12/01/Comparison/</url>
      
        <content type="html"><![CDATA[<h1 id="Compare-other-frameworks"><a href="#Compare-other-frameworks" class="headerlink" title="Compare other frameworks"></a>Compare other frameworks</h1><p>Welcome to this page, we believe that the purpose of coming here is to understand the difference between Ale and other large frameworks, which is exactly what we want to answer here.</p><p>Objectively speaking, as the core developer of Ale, we will definitely prefer Ale, and think it would be better to solve it with Ale for some problems. But here, we want to describe everything as fair and accurate as possible. Other frameworks have significant advantages, such as React’s vast ecosystem, or like Angular and Vue, which have numerous solutions for large projects. We will try to list all of them.</p><p><br></p><p>We also want to get help from ** to keep the documentation up to date, because the world of JavaScript is progressing too fast. If you notice an inaccurate or seemingly incorrect place, please submit a question for let us know.</p><p><br></p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React and Ale are almost identical. In fact, React is the inspiration for the early Ale, they all have:</p><ul><li>Update only the necessary [use <strong>diff</strong> algorithm] when status (data) is updated</li><li>Provides view components for <strong>responsive</strong> and <strong>componentized</strong>.</li><li>Focus on the core library and pass other functions to the relevant libraries.</li></ul><p>Because there are many similarities, we will spend more time comparing them in this block. Here we not only guarantee the accuracy of the technical content, but also take into account the balance considerations. We need to recognize where React is better than Ale, such as a richer ecosystem.</p><h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><p>Here we only tested for <strong>component definition</strong> and <strong>component rendering</strong>, so the test results do not represent full performance. But what is certain is that Ale outperforms React in both respects: (defining a component and rendering 1000 elements)</p><ul><li>Ale: 46~52 (ms)</li><li>React: 307~336 (ms)</li></ul><p>Of course, we also did a test on responsive dynamic rendering, which showed that Ale performed dynamic rendering 2.5 times faster than React.</p><p>The reason for the slowness of React may be due to the fact that we use <code>Babel</code> for dynamic rendering. But don’t forget, Ale doesn’t need to compile. If you compile React ahead of time, this will be unfair to Ale.</p><h4 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h4><p>In React, everything is JavaScript. Not only can HTML be expressed in JSX, but the trend is now increasingly incorporating CSS into JavaScript. This type of approach has its advantages, but there are some trade-offs that are not acceptable to every developer.</p><p>Ale’s overall idea is to embrace and extend the classic Web technologies. We will analyze it in detail below.</p><h5 id="JSX-vs-Templates"><a href="#JSX-vs-Templates" class="headerlink" title="JSX vs Templates"></a>JSX vs Templates</h5><p>In React, the rendering capabilities of all components rely on JSX. JSX is a syntactic sugar for writing JavaScript using XML syntax.</p><p>Using JSX has the following advantages:</p><ul><li>You can build your view page using the full programming language JavaScript functionality. For example, you can use temporary variables, JS’s own flow control, and directly reference the values ​​in the current JS scope.</li><li>Development tools support JSX is more advanced than other available Ale templates (eg, linting, type checking, editor auto-completion).</li></ul><p>But in fact, Ale also provides rendering functions, and even Ale abandons the traditional Mustache (JSX) template and chooses a less popular rendering function, which includes the following aspects:</p><ul><li>Depends on JavaScript’s own complete compiler, so we no longer need to manually write the template rendering function, which can effectively improve the overall speed of Ale template compilation, because the rendering function is closer to the JavaScript compiler itself than the template engine.</li><li>When you add a JavaScript expression to a JSX template, some compilers don’t have a corresponding syntax hint. At the same time, in some scenarios, you really need the ability to fully program JavaScript.</li></ul><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><h5 id="Expanding-up"><a href="#Expanding-up" class="headerlink" title="Expanding up"></a>Expanding up</h5><p>Well, to be honest, Ale is really not designed for large applications. We designed it to be able to handle almost all small and medium-sized applications.</p><p>In contrast, React provides powerful routing for large applications. And the React community is very innovative in terms of state management (such as Flux, Redux), which Ale can’t match.</p><h5 id="Downward-expansion"><a href="#Downward-expansion" class="headerlink" title="Downward expansion"></a>Downward expansion</h5><p>The React learning curve is steep, and you need to know JSX and ES2015 before you start learning React, because many examples use these syntaxes. You need to learn to build the system, although you can technically compile the code in real time with Babel, but this is not recommended for production environments.</p><p>However, Ale expands down to be very similar to jQuery. Because you just have to put the following tags on the page to run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;ale.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Then you can write the Ale code and apply it to production. You just need to replace it with the min version of the Ale file without worrying about other performance issues.</p><p>Since Ale’s start-up phase doesn’t require any complex knowledge points, such as ES2015 and JSX, developers can build simple applications in less than half an hour by reading the guide.</p><h4 id="Native-rendering"><a href="#Native-rendering" class="headerlink" title="Native rendering"></a>Native rendering</h4><p>React Native enables you to write native rendering capabilities for apps (iOS and Android) using the same component model. Being able to develop across multiple platforms at the same time is great for developers. In contrast, Ale is a bit weaker in this regard. But we didn’t stop here. As Ale slowly develops, these build systems will be released accordingly, so stay tuned.</p><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>Compared to React, Ale is extremely lightweight. Ale’s compressed files (not g-zip) [including APIs for manipulating DOM] are only about <strong>8kb</strong> size, while React’s core library plus DOM library is amazing<em> </em>108kb**.</p><h4 id="Preact-and-other-classes-React-library"><a href="#Preact-and-other-classes-React-library" class="headerlink" title="Preact and other classes React library"></a>Preact and other classes React library</h4><p>The libraries of the class React often share API and ecology with React as much as possible. Therefore the above comparison is equally applicable to them. They differ from React in that they have a smaller ecology and higher performance. However, because these libraries are not 100% compatible with all of the React ecosystem, some tools and auxiliary libraries may not be available. Or even if it seems to work, there may be incompatibility at any time, unless the React library you use is officially consistent with React.</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>It is time to compare the most important frameworks. Earlier we said that React was the inspiration for early Ale. In fact, Ale’s more inspiration comes from Vue, which is why some of the features and APIs provided by Ale are very similar to Vue.</p><p>However, although Ale and Vue have similarities in some places, we recommend that you install both Ale and Vue, because Vue can make Ale’s development more efficient. But if you don’t want to do this, you can just install a framework.</p><h4 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h4><p>Ale.js is much simpler than Vue in both API and design, and is more suitable for beginners to learn, so you can quickly master all of its features and invest in development.</p><h4 id="Flexibility-and-componentization"><a href="#Flexibility-and-componentization" class="headerlink" title="Flexibility and componentization"></a>Flexibility and componentization</h4><p>Compared to Angular, Vue.js is a more flexible and open solution. But in Ale, this situation will change.</p><p>In fact, Vue enforces one-way data flow between different components, which makes the data flow in the application clearer and easier to understand, but it also limits the flexibility between components. In Ale, there are only composite components, and there are no parent and child components, and any component in the composite component can interoperate because they share a set of data.</p><h4 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h4><p>Here we are the same as React, and only tested for <strong>component definition</strong> and <strong>component rendering</strong>, so the test results do not represent the performance of all operations. But what is certain is that Ale outperforms Vue in both respects: (defining a component and rendering 1000 elements)</p><ul><li>Ale: 46~52 (ms)</li><li>Vue: 181~228 (ms)</li></ul><h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>Vue provides an official type declaration and component decorator for TS, but not everyone wants to use TS. In small and medium-sized projects, the introduction of TS may not bring much obvious advantages. In these cases, using Ale would be a better choice.</p><h4 id="Volume-1"><a href="#Volume-1" class="headerlink" title="Volume"></a>Volume</h4><p>The separate vue.min.js file has a size of <strong>88kb</strong>, while Ale has a size of only about <strong>8kb</strong>, which is relatively lightweight compared to Vue.</p><h4 id="learning-curve"><a href="#learning-curve" class="headerlink" title="learning curve"></a>learning curve</h4><p>In this regard, both frameworks are similar, except that you need to have a good HTML and JavaScript foundation. With these basic skills, you can invest in development very quickly through the reading guide.</p><p>But specifically, Vue’s API area is much larger than Ale, so you need to understand more concepts to get productive. Of course, the complexity of Vue itself is because it is designed to target large, complex applications. But it is undeniable that this also makes it quite unfriendly to developers who are not experienced enough.</p><h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p>Of course, the editors don’t know much about Angular, so they don’t make a good comparison. Here, we hope that more experienced developers can help us write articles comparing Angular. You can click on the <strong>Edit page</strong> below, then go to Github to submit, thank you for your support and understanding!</p><h3 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h3><p>In fact, there is one more thing to add in terms of performance, because Vue and React use virtual DOM and diff algorithms. Ale actually traverses the real DOM tree directly, and then uses the diff algorithm to compare the differences. This is similar to Angular’s dirty check, and performance is affected. However, this approach also eliminates the need to create a virtual DOM tree.</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
